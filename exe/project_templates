#!/usr/bin/env ruby
# frozen_string_literal: true
# typed: strict

require "project_templates"
require "sorbet-runtime"

# have to load variables
# have to set paths

module ProjectTemplates
  # Wraps a possible source a dictionary loader can use. they give a strategy to know if it's "available"
  # what a description (for 'help'), a strategy for reading, and whether reading succeeded
  class DictionarySource
    extend T::Sig

    FILE_DESCRIPTON = T.let("read from a file %s", String)
    DATA_DESCRIPTON = T.let("read read raw from data", String)
    EMPTY_DESCRIPTION = T.let("just use an empty data source", String)

    class << self
      extend T::Sig

      sig { params(path: String, description: T.nilable(String)).returns(T.attached_class) }
      # make a new file dictionary source
      def file(path, description: nil)
        new(path: Pathname.new(path), description: description || FILE_DESCRIPTON % path.to_s)
      end

      sig { params(data: String, description: T.nilable(String)).returns(T.attached_class) }
      # make a new raw data source
      def string(data, description: DATA_DESCRIPTON)
        new(data:, description:)
      end

      sig { params(description: T.nilable(String)).returns(T.attached_class) }
      # make a new raw data source
      def empty(description: EMPTY_DESCRIPTION)
        new(data: {}.to_s, description:)
      end

      # need a way to handle environment variables
      # one for points at file
      # one for provides raw data
    end

    sig { returns(T.nilable(String)) }
    # a description for the load source for display in help / error messages
    attr_accessor :description

    sig { returns(T.nilable(String)) }
    # the data from the provided as a load source
    attr_accessor :data

    sig { returns(T.nilable(Pathname)) }
    # the path to a file where data can be loaded
    attr_accessor :path

    sig { returns(T.nilable(String)) }
    # If the data source was loaded then this is the data that was loaded from it
    attr_reader :loaded_data

    sig { returns(T::Boolean) }
    # Did loading the data happen successfully?
    def success
      !@loaded_data.nil?
    end
    alias success? success

    sig { returns(T.nilable(String)) }
    # If the data source was loaded then this is the data that was loaded from it
    attr_reader :failure_message

    sig { params(data: T.nilable(String), path: T.nilable(Pathname), description: T.nilable(String)).void }
    # initializes the data source
    def initialize(data: nil, path: nil, description: nil)
      @data = data
      @path = path
      @failure_message = nil
      @description = description.to_s
      @loaded_data = data
    end

    sig { returns(T::Boolean) }
    # maybe this should be passed in the initialize?
    # if data then raw.  elsif file then file exists && readable
    def loadable?
      return true if data

      path.exist?
      # check if file exists
    end

    sig { void }
    # tries to load data and verifies if it worked or not
    # data pass to dictionary
    # file read then pass to dictionary
    def load
      return if success?

      @loaded_data = File.read(path)
    rescue Errno::ENOENT, Errno::EISDIR, Errno::EACCES => e
      @loaded_data = nil
      @failure_message = "Error loading file: #{e.message}"
    end
  end

  # This takes a series of possible "sources" for a directory in priority order
  # and then finds the first match and uses it to instantiate a directory
  class DictionaryLoader
    extend T::Sig

    sig { returns(T::Array[DictionarySource]) }
    # The ordered list of locations that will be used to load a file
    attr_reader :sources

    sig { returns(T.nilable(Dictionary)) }
    # The dictionary, but only if loading was successful
    attr_reader :dictionary

    sig { returns(T::Boolean) }
    # Did loading succeed?
    attr_reader :success
    alias success? success

    sig { params(sources: DictionarySource).void }
    # Pass in n ordered list of sources. They'll be checked in order by the loader.
    def initialize(*sources)
      @sources = sources.to_a
      @success = false
      @dictionary = nil
    end

    sig { returns(T::Array[DictionarySource]) }
    # if loading started, this is the detected list of 'loadable' sources
    def loadable_sources
      @loadable_sources ||= sources.select(&:loadable?)
    end

    sig { returns(T.nilable(Dictionary)) }
    # Does the actual loading of data. Goes through sources one at a time until
    # an usable one is found then parses that into a dictionary.
    def load
      # this should be a loop that rescues failures and moves on
      data = loadable_sources.find { |source| source.load && source.success? }
      @dictionary = Dictionary.load(data.loaded_data) if data
    end
  end
end

main_config_loader = ProjectTemplates::DictionaryLoader.new(
  # env project_templates_config
  # env xdg_config_home project_templates/config.yaml
  ProjectTemplates::DictionarySource.file(
    Pathname.new(ENV.fetch("HOME", "~")).join(".config/project_templates/config.yaml").expand_path.to_s
  ),
  ProjectTemplates::DictionarySource.string(
    { name: "cute haxor", email: "project_templates@cutehax0r.com" }.to_json
  ),
  ProjectTemplates::DictionarySource.file(
    Pathname.new(__dir__).join("../examples/config.yaml").to_s
  ),
  ProjectTemplates::DictionarySource.empty
)

file_config = main_config_loader.load
puts file_config
# Initialization process
# 1. set task (build project, list, help, version, etc)
#    - bail early if help, version, etc. do the thing
# 1. Load global config
#    - bail early if list. do the thing
# 1. prerp to run
#    - set project name and target name
#    - Load project variables
#    - load global variables
#    - load run variables
#    - validate paths
#    - validate vars
# 1. dryrun: compute changes and print output
# 1. build it
#
# Global config
#   --config -c
#   ENV["CONFIG"]
#   ~/.config/project_templates/config.yaml
#   default config
# Contents:
#   template_path
#   working_directory
#   vars_file
#   vars
#     global
#     project
#       project_kind_1
#       project_kind_2
#
# working_directory
#   --working-directory -w
#   global_config.working_directory
#   ENV["working_directory"]
#   Dir.cwd

# template_path
#   --template-path -t
#   global_config.template_path
#   ENV["template_path"]
#   ~/.local/share/project_templates/projects

# project_path
#   --project-path -p
#   template_path + project_name

# target_path
#   --target-path -o
#   working_directory + target_name

# project_name
#   --project -j
#   argv[1]

# target_name
#   --target-name -n
#   argv[2]

# global_variables
#   --global-variables -g
#   ENV["global_variables_path"]
#   ~/.config/project_templates/variables.yaml
#   global_config.vars

# project_variables
#   --project-variables -r
#   project_path + variables.yaml

# run variables
#   --variables -s

# def initialize()

config = ProjectTemplates::Config.new(dry_run: true)
app = ProjectTemplates::App.new(config)
app.run
